#!/bin/bash

# System Cleaner Script
#
# A script to help identify unused files and applications on Ubuntu.
#
# Warning: This script is a powerful tool. It does not delete anything
# automatically, but helps you generate scripts to do so. Always
# review the generated scripts and back up your data before running them.

set -o pipefail

# --- Configuration ---
# Default number of days to consider a file "old"
DEFAULT_DAYS_OLD=180
# Default path to scan
DEFAULT_SCAN_PATH="$HOME"
# Excluded directories (comma-separated)
DEFAULT_EXCLUDES=".cache,.config,.local/share/Trash,.git,.vscode"

# --- UI & Helper Functions ---

# Color definitions
C_RESET='\033[0m'
C_RED='\033[0;31m'
C_GREEN='\033[0;32m'
C_YELLOW='\033[0;33m'
C_CYAN='\033[0;36m'

info() {
    echo -e "${C_CYAN}[INFO] $1${C_RESET}"
}

warn() {
    echo -e "${C_YELLOW}[WARN] $1${C_RESET}"
}

error() {
    echo -e "${C_RED}[ERROR] $1${C_RESET}"
}

# --- File Scanning Logic ---

scan_for_old_files() {
    info "This utility will scan for files that have not been accessed recently."

    read -p "Enter the number of days to consider a file 'old' [Default: $DEFAULT_DAYS_OLD]: " days_old
    days_old=${days_old:-$DEFAULT_DAYS_OLD}

    read -p "Enter the absolute path to scan [Default: $DEFAULT_SCAN_PATH]: " scan_path
    scan_path=${scan_path:-$DEFAULT_SCAN_PATH}

    read -p "Enter comma-separated directories to exclude [Default: $DEFAULT_EXCLUDES]: " excludes
    excludes=${excludes:-$DEFAULT_EXCLUDES}

    if [[ ! -d "$scan_path" ]]; then
        error "The path '$scan_path' does not exist or is not a directory."
        return 1
    fi

    info "Scanning for files in '$scan_path' not accessed in the last $days_old days..."

    # Build the find command's exclude arguments
    exclude_args=()
    IFS=',' read -ra exclude_arr <<< "$excludes"
    for item in "${exclude_arr[@]}"; do
        # We need to exclude the path, so we use -path and add a wildcard
        # e.g., /home/user/.cache/*
        exclude_args+=(-o -path "$scan_path/$item/*")
    done

    # The first element of exclude_args is '-o', which we don't want at the start of the expression
    # We remove it. The find expression will start with `\( -path ...`
    unset 'exclude_args[0]'

    # Find files and store them in an array
    # We use `printf` for better control over the output format
    # Format:epoch_atime|size_bytes|path
    mapfile -t found_files < <(find "$scan_path" \( "${exclude_args[@]}" \) -prune -o -type f -atime +"$days_old" -printf "%A@|%s|%p\n" 2>/dev/null | sort -n)

    if [[ ${#found_files[@]} -eq 0 ]]; then
        info "No files found matching the criteria."
        return 0
    fi

    info "Found ${#found_files[@]} old files. Displaying the top 20 largest."
    echo "----------------------------------------------------------------"
    # Display header
    printf "%-20s | %-12s | %s\n" "Last Accessed" "Size" "Path"
    echo "----------------------------------------------------------------"

    # Sort by size (field 2) descending and take top 20
    # Then print
    (for line in "${found_files[@]}"; do
        echo "$line"
    done) | sort -t'|' -k2,2nr | head -n 20 | while IFS='|' read -r atime size path; do
        # Format the date and size for display
        last_access_date=$(date -d "@$atime" '+%Y-%m-%d %H:%M:%S')
        human_readable_size=$(numfmt --to=iec-i --suffix=B --format="%-8s" "$size")
        printf "%-20s | %-12s | %s\n" "$last_access_date" "$human_readable_size" "$path"
    done

    echo "----------------------------------------------------------------"
    warn "This is just a preview of the largest files."

    read -p "Do you want to generate a removal script for ALL ${#found_files[@]} found files? [y/N]: " confirm
    if [[ "$confirm" =~ ^[yY]$ ]]; then
        generate_removal_script "${found_files[@]}"
    else
        info "No action taken."
    fi
}

generate_removal_script() {
    local files_to_process=("$@")
    local script_path="./remove_old_files_$(date +%Y%m%d_%H%M%S).sh"

    info "Generating removal script at: $script_path"

    echo "#!/bin/bash" > "$script_path"
    echo "#" >> "$script_path"
    echo "# This script was generated by the System Cleaner." >> "$script_path"
    echo "# It contains commands to delete files identified as 'old'." >> "$script_path"
    echo "#" >> "$script_path"
    echo "# !!! WARNING !!!" >> "$script_path"
    echo "# Review these commands carefully before running this script." >> "$script_path"
    echo "# Make sure you have backed up any important data." >> "$script_path"
    echo "# To execute, run: bash $script_path" >> "$script_path"
    echo "" >> "$script_path"

    total_size=0
    for line in "${files_to_process[@]}"; do
        IFS='|' read -r _ size path <<< "$line"
        echo "rm -v \"$path\" # Size: $(numfmt --to=iec-i --suffix=B --format="%-8s" "$size")" >> "$script_path"
        total_size=$((total_size + size))
    done

    echo "" >> "$script_path"
    echo "# Total size of files to be removed: $(numfmt --to=iec-i --suffix=B --format="%f" "$total_size")" >> "$script_path"

    chmod +x "$script_path"
    info "Script generated successfully."
    warn "REVIEW THE SCRIPT '$script_path' AND RUN IT MANUALLY IF YOU ARE SURE."
}

# --- Application Scanning Logic ---

scan_for_applications() {
    info "This utility helps you review manually installed applications."
    echo
    echo "Choose a package manager to scan:"
    echo "1. APT (Debian packages)"
    echo "2. Snap"
    echo "3. Flatpak"
    echo "4. Back to main menu"
    echo
    read -p "Enter your choice [1-4]: " choice

    case "$choice" in
        1)
            scan_apt_packages
            ;;
        2)
            scan_snap_packages
            ;;
        3)
            scan_flatpak_packages
            ;;
        4)
            return
            ;;
        *)
            error "Invalid choice."
            ;;
    esac
}

scan_apt_packages() {
    info "Scanning for manually installed APT packages..."

    # Get manually installed packages, then get their details.
    # This can be slow, so we should inform the user.
    info "This may take a moment..."
    mapfile -t packages < <(apt-mark showmanual)

    if [[ ${#packages[@]} -eq 0 ]]; then
        info "No manually installed packages found."
        return 0
    fi

    declare -a package_details
    for pkg in "${packages[@]}"; do
        # Get installed size, description.
        # The 'Installed-Size' is in KB, so we convert to bytes.
        details=$(dpkg-query -W -f='${Installed-Size}|${binary:summary}\n' "$pkg" 2>/dev/null)
        if [[ -n "$details" ]]; then
            size_kb=$(echo "$details" | cut -d'|' -f1)
            size_bytes=$((size_kb * 1024))
            description=$(echo "$details" | cut -d'|' -f2)
            package_details+=("$pkg|$size_bytes|$description")
        fi
    done

    info "Found ${#package_details[@]} manually installed packages. Displaying them sorted by size."
    echo "--------------------------------------------------------------------------------"
    printf "%-30s | %-12s | %s\n" "Package" "Size" "Description"
    echo "--------------------------------------------------------------------------------"

    # Sort by size (field 2) descending and print
    (for line in "${package_details[@]}"; do
        echo "$line"
    done) | sort -t'|' -k2,2nr | while IFS='|' read -r pkg size desc; do
        human_readable_size=$(numfmt --to=iec-i --suffix=B --format="%-8s" "$size")
        printf "%-30s | %-12s | %s\n" "$pkg" "$human_readable_size" "$desc"
    done

    echo "--------------------------------------------------------------------------------"
    warn "This list shows manually installed packages. Dependencies are not shown."

    read -p "Do you want to generate a removal script for selected packages? [y/N]: " confirm
    if [[ "$confirm" =~ ^[yY]$ ]]; then
        generate_app_removal_script "apt" "${package_details[@]}"
    else
        info "No action taken."
    fi
}

scan_snap_packages() {
    if ! command -v snap &> /dev/null; then
        warn "Snap command not found. Skipping snap package scan."
        return
    fi

    info "Scanning for installed Snap packages..."
    # Format: Name | Size | Notes
    mapfile -t snaps < <(snap list | tail -n +2 | awk '{print $1"|"$3"|"$5}')

    if [[ ${#snaps[@]} -eq 0 ]]; then
        info "No Snap packages found."
        return 0
    fi

    info "Found ${#snaps[@]} Snap packages."
    echo "--------------------------------------------------------------------------------"
    printf "%-30s | %-12s | %s\n" "Package" "Size" "Notes"
    echo "--------------------------------------------------------------------------------"

    for line in "${snaps[@]}"; do
        IFS='|' read -r pkg size notes <<< "$line"
        printf "%-30s | %-12s | %s\n" "$pkg" "$size" "$notes"
    done
    echo "--------------------------------------------------------------------------------"

    read -p "Do you want to generate a removal script for selected packages? [y/N]: " confirm
    if [[ "$confirm" =~ ^[yY]$ ]]; then
        generate_app_removal_script "snap" "${snaps[@]}"
    else
        info "No action taken."
    fi
}

scan_flatpak_packages() {
    if ! command -v flatpak &> /dev/null; then
        warn "Flatpak command not found. Skipping flatpak package scan."
        return
    fi

    info "Scanning for installed Flatpak packages..."
    # Format: Application ID | Size
    mapfile -t flatpaks < <(flatpak list --columns=application,size)

    if [[ ${#flatpaks[@]} -eq 0 ]]; then
        info "No Flatpak packages found."
        return 0
    fi

    info "Found ${#flatpaks[@]} Flatpak packages."
    echo "--------------------------------------------------------------------------------"
    printf "%-50s | %s\n" "Application ID" "Size"
    echo "--------------------------------------------------------------------------------"

    for line in "${flatpaks[@]}"; do
        # Flatpak output is tab-separated
        app_id=$(echo "$line" | awk -F'\t' '{print $1}')
        size=$(echo "$line" | awk -F'\t' '{print $2}')
        printf "%-50s | %s\n" "$app_id" "$size"
    done
    echo "--------------------------------------------------------------------------------"

    read -p "Do you want to generate a removal script for selected packages? [y/N]: " confirm
    if [[ "$confirm" =~ ^[yY]$ ]]; then
        # We need to re-format the flatpak list to be pipe-delimited for the generic function
        declare -a flatpak_details
        for line in "${flatpaks[@]}"; do
            app_id=$(echo "$line" | awk -F'\t' '{print $1}')
            flatpak_details+=("$app_id|") # No size or desc needed for removal command
        done
        generate_app_removal_script "flatpak" "${flatpak_details[@]}"
    else
        info "No action taken."
    fi
}

generate_app_removal_script() {
    local type=$1
    shift
    local packages_to_process=("$@")
    local packages_to_remove=()

    if [[ "$USE_DIALOG" -eq 1 ]]; then
        local checklist_options=()
        for line in "${packages_to_process[@]}"; do
            IFS='|' read -r name size_or_notes desc <<< "$line"
            local display_name="$name"
            local display_info=""
            if [[ "$type" == "apt" ]]; then
                human_readable_size=$(numfmt --to=iec-i --suffix=B --format="%-8s" "$size_or_notes")
                display_info="$human_readable_size - $desc"
            elif [[ "$type" == "snap" ]]; then
                display_info="Size: $size_or_notes"
            fi
            checklist_options+=("$display_name" "$display_info" "off")
        done

        selected_packages=$(dialog --keep-tite --checklist "Select packages to remove (Space to toggle)" 20 100 15 "${checklist_options[@]}" 2>&1 >/dev/tty)

        if [[ -z "$selected_packages" ]]; then
            info "No packages selected. Aborting."
            return
        fi

        # The output from dialog is quoted, so we need to handle that
        # e.g., "package1" "package2"
        read -ra packages_to_remove <<< "$selected_packages"

    else
        info "Please enter the exact names of the packages you want to remove."
        info "Separate multiple packages with spaces."
        read -p "Packages to remove: " -ra packages_to_remove
    fi

    if [[ ${#packages_to_remove[@]} -eq 0 ]]; then
        info "No packages selected. Aborting."
        return
    fi

    local script_path="./remove_${type}_packages_$(date +%Y%m%d_%H%M%S).sh"
    info "Generating removal script at: $script_path"

    echo "#!/bin/bash" > "$script_path"
    echo "#" >> "$script_path"
    echo "# This script was generated by the System Cleaner to remove ${type} packages." >> "$script_path"
    echo "#" >> "$script_path"
    echo "# !!! WARNING !!!" >> "$script_path"
    echo "# Review these commands carefully before running this script." >> "$script_path"
    echo "" >> "$script_path"

    case "$type" in
        apt)
            echo "sudo apt-get purge ${packages_to_remove[*]}" >> "$script_path"
            echo "sudo apt-get autoremove" >> "$script_path"
            ;;
        snap)
            for pkg in "${packages_to_remove[@]}"; do
                echo "sudo snap remove \"$pkg\"" >> "$script_path"
            done
            ;;
        flatpak)
            echo "flatpak uninstall --delete-data ${packages_to_remove[*]}" >> "$script_path"
            ;;
    esac

    chmod +x "$script_path"
    info "Script generated successfully."
    warn "REVIEW THE SCRIPT '$script_path' AND RUN IT MANUALLY IF YOU ARE SURE."
}


# --- Main Logic ---

# Check for dialog and set a flag
USE_DIALOG=0
if command -v dialog &> /dev/null; then
    USE_DIALOG=1
fi

main() {
    if [[ "$USE_DIALOG" -eq 1 ]]; then
        cmd=(dialog --keep-tite --menu "System Cleaner" 12 50 3)
        options=(1 "Scan for old files"
                 2 "Scan for installed applications"
                 3 "Exit")

        while true; do
            choice=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)

            case "$choice" in
                1) scan_for_old_files ;;
                2) scan_for_applications ;;
                3) break ;;
                *) break ;; # Exit on cancel
            esac
        done
        # Clear the screen after dialog exits
        clear
    else
        # Fallback to simple text menu
        while true; do
            echo "Welcome to the System Cleaner script."
            echo "==================================="
            echo
            echo "Please choose an option:"
            echo "1. Scan for old files"
            echo "2. Scan for installed applications"
            echo "3. Exit"
            echo
            read -p "Enter your choice [1-3]: " choice

            case "$choice" in
                1) scan_for_old_files; break ;;
                2) scan_for_applications; break ;;
                3) echo "Exiting."; exit 0 ;;
                *) error "Invalid choice. Please try again." ;;
            esac
        done
    fi
}

# --- Script Entry Point ---
main
